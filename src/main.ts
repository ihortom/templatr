import { app, BrowserWindow, Menu, ipcMain, shell, clipboard } from 'electron';
import fs from 'fs';
import os from 'os';
import path from 'path';
import YAML from 'yaml';


// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code 
// (depending on whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const ABOUT_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
process.env["ELECTRON_DISABLE_SECURITY_WARNINGS"] = 'true';


const createWindow = (): void => {

    let width: number;
    if (process.env.NODE_ENV == 'development') {
        width = 1300;
    }
    else {
        width = 1000;
    }

    // Create the browser window
    const mainWindow = new BrowserWindow({
        title: "Templatr",
        width: width,
        height: 659,
        minWidth: 800,
        minHeight: 200,
        backgroundColor: "white",
        resizable: true,
        webPreferences: {
            preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY
        }
    });

    // and load the index.html of the app
    mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

    // Open the DevTools
    if (process.env.NODE_ENV == 'development') {
        mainWindow.webContents.openDevTools();
    }

    // App menu
    const menu = Menu.buildFromTemplate([
        {
            label: 'Application',
            submenu: [
                {
                    label:'About',
                    click() { 
                        openAboutWindow();
                    }
                },
                { type:'separator' },
                {
                    label:'Edit Templates',
                    click() { 
                        shell.openPath(path.join(os.homedir(), '.templatr', 'template.yaml'))
                    }
                },
                {
                    label:'Edit Substitutes List',
                    click() {
                        shell.openPath(path.join(os.homedir(), '.templatr', 'substitutes.yaml'))
                    }
                },
                { type:'separator' },
                {
                    label:'Relaunch App',
                    click() { 
                        app.relaunch({ args: process.argv.slice(1).concat(['--relaunch']) })
                        app.exit(0)
                    }
                },
                { type:'separator' },
                { 
                    label:'Exit', 
                    click() { 
                        app.quit() 
                    } 
                }
            ]
        },
        {
            label: "Edit",
            submenu: [
                { label: "Cut", accelerator: "CmdOrCtrl+X", role: "cut" },
                { label: "Copy", accelerator: "CmdOrCtrl+C", role: "copy" },
                { label: "Paste", accelerator: "CmdOrCtrl+V", role: "paste" },
                { label: "Select All", accelerator: "CmdOrCtrl+A", role: "selectAll" }
            ]
        }
    ]);

    Menu.setApplicationMenu(menu);
};

let aboutWindow: BrowserWindow = null;
  
const openAboutWindow = ():void => {

    if (aboutWindow) {
        aboutWindow.focus();
        return;
    }

    let width: number;
    if (process.env.NODE_ENV == 'development') {
        width = 1000;
    }
    else {
        width = 360;
    }

    // Create the browser window
    aboutWindow = new BrowserWindow({
        height: 370,
        resizable: false,
        width: width,
        title: 'About Templatr',
        minimizable: false,
        fullscreenable: false
    });

    aboutWindow.loadURL(ABOUT_WINDOW_WEBPACK_ENTRY);

    // Open the DevTools
    if (process.env.NODE_ENV == 'development') {
        aboutWindow.webContents.openDevTools();
    }

    aboutWindow.on('closed', function() {
        aboutWindow = null;
    });
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
    if (process.platform !== 'darwin') {
        app.quit();
    }
});

app.on('activate', () => {
    // On OS X it's common to re-create a window in the app when the
    // dock icon is clicked and there are no other windows open.
    if (BrowserWindow.getAllWindows().length === 0) {
        createWindow();
    }
});


/*
** Inter Process Communication
*/

ipcMain.on('show-context-menu', (event) => {
    const template = [
        {
            label: 'Copy',
            click: () => { event.sender.send('context-menu-command', 'copy') }
        }
    ]
    const contextMenu = Menu.buildFromTemplate(template)
    contextMenu.popup({ window: BrowserWindow.fromWebContents(event.sender) })
});

ipcMain.on('getTemplates', (event) => {
    const pathToTemplates: string = path.join(os.homedir(), '.templatr', 'template.yaml'); 

    if (fs.existsSync(pathToTemplates)) {
        try {
            const file: string = fs.readFileSync(pathToTemplates, 'utf8');

            if (file.length > 0) {
                const data = YAML.parse(file);
                event.returnValue = data;
            }
            else {
                event.returnValue = {};
            }
        }
        catch(err) {
            event.returnValue = { error: err.message };
        }
    }
    else {  // create empty file
        try {
            const appDir = path.join(os.homedir(), '.templatr')
            if (!fs.existsSync(appDir)){
                fs.mkdirSync(appDir);
            }
            fs.writeFileSync(pathToTemplates, '', {flag: 'w', encoding: 'utf-8'});
        }
        catch(err) {
            event.returnValue = {error: "Could not create templates file"};
        }
        event.returnValue = {};
    }
});

ipcMain.on("getSubstitutes", (event) => {   
    const pathToSubstitutes = path.join(os.homedir(), '.templatr', 'substitutes.yaml');

    if (fs.existsSync(pathToSubstitutes)) {
        try {
            const file = fs.readFileSync(pathToSubstitutes, 'utf8');
            if (file.length > 0) {
                const data = YAML.parse(file);
                event.returnValue =  data;
            }
            else {
                event.returnValue =  [];
            }
        }
        catch(err) {
            event.returnValue = err.message;
        }
    }
    else {  // create empty file
        try {
            const appDir = path.join(os.homedir(), '.templatr')
            if (!fs.existsSync(appDir)){
                fs.mkdirSync(appDir);
            }
            fs.writeFileSync(pathToSubstitutes, '', {flag: 'w', encoding: 'utf-8'});
        }
        catch(err) {
            event.returnValue = "Could not create variable substututes file";
        }
        event.returnValue = [];
    }
});

ipcMain.on("getComments", (event) => {
    const pathToTemplates = path.join(os.homedir(), '.templatr', 'template.yaml');

    try {
        const file = fs.readFileSync(pathToTemplates, 'utf8');

        if (file.length > 0) {
            const matches = file.matchAll(/(.*)#(.*)/g);
            const comments = [...matches].map(m => new Object({[m[1].trim().replace(/"/g, '').replace('- ', '')]: m[2].trim()}));
            
            const data = {};
            comments.forEach(i => {
                const key: string = Object.keys(i)[0];
                const value: string = Object.values(i)[0];
                (data as Record<string, string>)[key] = value;
            });
            event.returnValue = data;
        }
        else {
            event.returnValue = {};
        }
    }
    catch(err) {
        event.returnValue = {};
    }
});

ipcMain.on("getClipboard", (event) => {
    event.returnValue = clipboard.readText();
});

ipcMain.on("setClipboard", (_, text) => {
    clipboard.writeText(text);
});
